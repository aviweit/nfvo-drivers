/*
 * SOL005 - NS Lifecycle Management Interface
 * SOL005 - NS Lifecycle Management Interface IMPORTANT: Please note that this file might be not aligned to the current version of the ETSI Group Specification it refers to and has not been approved by the ETSI NFV ISG. In case of discrepancies the published ETSI Group Specification takes precedence. Please report bugs to https://forge.etsi.org/bugzilla/buglist.cgi?component=Nfv-Openapis 
 *
 * OpenAPI spec version: 1.1.0-impl:etsi.org:ETSI_NFV_OpenAPI:1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package it.nextworks.openapi.msno.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import it.nextworks.openapi.msno.model.Mask;
import it.nextworks.openapi.msno.model.PortRange;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * The NfpRule data type is an expression of the conditions that shall be met in order for the NFP to be applicable to the packet. The condition acts as a flow classifier and it is met only if all the values expressed in the condition are matched by those in the packet. It shall comply with the provisions defined in Table 6.5.3.40-1. 
 */
@ApiModel(description = "The NfpRule data type is an expression of the conditions that shall be met in order for the NFP to be applicable to the packet. The condition acts as a flow classifier and it is met only if all the values expressed in the condition are matched by those in the packet. It shall comply with the provisions defined in Table 6.5.3.40-1. ")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2019-11-08T16:52:33.422+01:00")
public class NfpRule {
  @SerializedName("etherDestinationAddress")
  private String etherDestinationAddress = null;

  @SerializedName("etherSourceAddress")
  private String etherSourceAddress = null;

  /**
   * Human readable description for the VNFFG. 
   */
  @JsonAdapter(EtherTypeEnum.Adapter.class)
  public enum EtherTypeEnum {
    IPV4("IPV4"),
    
    IPV6("IPV6");

    private String value;

    EtherTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EtherTypeEnum fromValue(String text) {
      for (EtherTypeEnum b : EtherTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<EtherTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EtherTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EtherTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return EtherTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("etherType")
  private EtherTypeEnum etherType = null;

  @SerializedName("vlanTag")
  private List<String> vlanTag = null;

  /**
   * Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \&quot;Protocol\&quot; to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \&quot;Next Header\&quot; field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP 
   */
  @JsonAdapter(ProtocolEnum.Adapter.class)
  public enum ProtocolEnum {
    TCP("TCP"),
    
    UDP("UDP"),
    
    ICMP("ICMP");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProtocolEnum fromValue(String text) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("protocol")
  private ProtocolEnum protocol = null;

  @SerializedName("dscp")
  private String dscp = null;

  @SerializedName("sourcePortRange")
  private PortRange sourcePortRange = null;

  @SerializedName("destinationPortRange")
  private PortRange destinationPortRange = null;

  @SerializedName("sourceIpAddressPrefix")
  private String sourceIpAddressPrefix = null;

  @SerializedName("destinationIpAddressPrefix")
  private String destinationIpAddressPrefix = null;

  @SerializedName("extendedCriteria")
  private List<Mask> extendedCriteria = null;

  public NfpRule etherDestinationAddress(String etherDestinationAddress) {
    this.etherDestinationAddress = etherDestinationAddress;
    return this;
  }

   /**
   * Indicates a destination Mac address. 
   * @return etherDestinationAddress
  **/
  @ApiModelProperty(value = "Indicates a destination Mac address. ")
  public String getEtherDestinationAddress() {
    return etherDestinationAddress;
  }

  public void setEtherDestinationAddress(String etherDestinationAddress) {
    this.etherDestinationAddress = etherDestinationAddress;
  }

  public NfpRule etherSourceAddress(String etherSourceAddress) {
    this.etherSourceAddress = etherSourceAddress;
    return this;
  }

   /**
   * Indicates a source Mac address. 
   * @return etherSourceAddress
  **/
  @ApiModelProperty(value = "Indicates a source Mac address. ")
  public String getEtherSourceAddress() {
    return etherSourceAddress;
  }

  public void setEtherSourceAddress(String etherSourceAddress) {
    this.etherSourceAddress = etherSourceAddress;
  }

  public NfpRule etherType(EtherTypeEnum etherType) {
    this.etherType = etherType;
    return this;
  }

   /**
   * Human readable description for the VNFFG. 
   * @return etherType
  **/
  @ApiModelProperty(value = "Human readable description for the VNFFG. ")
  public EtherTypeEnum getEtherType() {
    return etherType;
  }

  public void setEtherType(EtherTypeEnum etherType) {
    this.etherType = etherType;
  }

  public NfpRule vlanTag(List<String> vlanTag) {
    this.vlanTag = vlanTag;
    return this;
  }

  public NfpRule addVlanTagItem(String vlanTagItem) {
    if (this.vlanTag == null) {
      this.vlanTag = new ArrayList<String>();
    }
    this.vlanTag.add(vlanTagItem);
    return this;
  }

   /**
   * Indicates a VLAN identifier in an IEEE 802.1Q-2014 tag [6] Multiple tags can be included for QinQ stacking. See note. 
   * @return vlanTag
  **/
  @ApiModelProperty(value = "Indicates a VLAN identifier in an IEEE 802.1Q-2014 tag [6] Multiple tags can be included for QinQ stacking. See note. ")
  public List<String> getVlanTag() {
    return vlanTag;
  }

  public void setVlanTag(List<String> vlanTag) {
    this.vlanTag = vlanTag;
  }

  public NfpRule protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

   /**
   * Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \&quot;Protocol\&quot; to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \&quot;Next Header\&quot; field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP 
   * @return protocol
  **/
  @ApiModelProperty(value = "Indicates the L4 protocol, For IPv4 [7] this corresponds to the field called \"Protocol\" to identify the next level protocol. For IPv6 [28] this corresponds to the field is called the \"Next Header\" field. Permitted values: Any keyword defined in the IANA protocol registry [1], e.g.: TCP UDP ICMP ")
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public NfpRule dscp(String dscp) {
    this.dscp = dscp;
    return this;
  }

   /**
   * For IPv4 [7] a string of \&quot;0\&quot; and \&quot;1\&quot; digits that corresponds to the 6-bit Differentiated Services Code Point (DSCP) field of the IP header. For IPv6 [28] a string of \&quot;0\&quot; and \&quot;1\&quot; digits that corresponds to the 6 differentiated services bits of the traffic class header field 
   * @return dscp
  **/
  @ApiModelProperty(value = "For IPv4 [7] a string of \"0\" and \"1\" digits that corresponds to the 6-bit Differentiated Services Code Point (DSCP) field of the IP header. For IPv6 [28] a string of \"0\" and \"1\" digits that corresponds to the 6 differentiated services bits of the traffic class header field ")
  public String getDscp() {
    return dscp;
  }

  public void setDscp(String dscp) {
    this.dscp = dscp;
  }

  public NfpRule sourcePortRange(PortRange sourcePortRange) {
    this.sourcePortRange = sourcePortRange;
    return this;
  }

   /**
   * Indicates a range of source ports 
   * @return sourcePortRange
  **/
  @ApiModelProperty(value = "Indicates a range of source ports ")
  public PortRange getSourcePortRange() {
    return sourcePortRange;
  }

  public void setSourcePortRange(PortRange sourcePortRange) {
    this.sourcePortRange = sourcePortRange;
  }

  public NfpRule destinationPortRange(PortRange destinationPortRange) {
    this.destinationPortRange = destinationPortRange;
    return this;
  }

   /**
   * Indicates a range of destination ports. 
   * @return destinationPortRange
  **/
  @ApiModelProperty(value = "Indicates a range of destination ports. ")
  public PortRange getDestinationPortRange() {
    return destinationPortRange;
  }

  public void setDestinationPortRange(PortRange destinationPortRange) {
    this.destinationPortRange = destinationPortRange;
  }

  public NfpRule sourceIpAddressPrefix(String sourceIpAddressPrefix) {
    this.sourceIpAddressPrefix = sourceIpAddressPrefix;
    return this;
  }

   /**
   * Indicates the source IP address range in CIDR format. 
   * @return sourceIpAddressPrefix
  **/
  @ApiModelProperty(value = "Indicates the source IP address range in CIDR format. ")
  public String getSourceIpAddressPrefix() {
    return sourceIpAddressPrefix;
  }

  public void setSourceIpAddressPrefix(String sourceIpAddressPrefix) {
    this.sourceIpAddressPrefix = sourceIpAddressPrefix;
  }

  public NfpRule destinationIpAddressPrefix(String destinationIpAddressPrefix) {
    this.destinationIpAddressPrefix = destinationIpAddressPrefix;
    return this;
  }

   /**
   * Indicates the destination IP address range in CIDR format. 
   * @return destinationIpAddressPrefix
  **/
  @ApiModelProperty(value = "Indicates the destination IP address range in CIDR format. ")
  public String getDestinationIpAddressPrefix() {
    return destinationIpAddressPrefix;
  }

  public void setDestinationIpAddressPrefix(String destinationIpAddressPrefix) {
    this.destinationIpAddressPrefix = destinationIpAddressPrefix;
  }

  public NfpRule extendedCriteria(List<Mask> extendedCriteria) {
    this.extendedCriteria = extendedCriteria;
    return this;
  }

  public NfpRule addExtendedCriteriaItem(Mask extendedCriteriaItem) {
    if (this.extendedCriteria == null) {
      this.extendedCriteria = new ArrayList<Mask>();
    }
    this.extendedCriteria.add(extendedCriteriaItem);
    return this;
  }

   /**
   * Indicates values of specific bits in a frame. 
   * @return extendedCriteria
  **/
  @ApiModelProperty(value = "Indicates values of specific bits in a frame. ")
  public List<Mask> getExtendedCriteria() {
    return extendedCriteria;
  }

  public void setExtendedCriteria(List<Mask> extendedCriteria) {
    this.extendedCriteria = extendedCriteria;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NfpRule nfpRule = (NfpRule) o;
    return Objects.equals(this.etherDestinationAddress, nfpRule.etherDestinationAddress) &&
        Objects.equals(this.etherSourceAddress, nfpRule.etherSourceAddress) &&
        Objects.equals(this.etherType, nfpRule.etherType) &&
        Objects.equals(this.vlanTag, nfpRule.vlanTag) &&
        Objects.equals(this.protocol, nfpRule.protocol) &&
        Objects.equals(this.dscp, nfpRule.dscp) &&
        Objects.equals(this.sourcePortRange, nfpRule.sourcePortRange) &&
        Objects.equals(this.destinationPortRange, nfpRule.destinationPortRange) &&
        Objects.equals(this.sourceIpAddressPrefix, nfpRule.sourceIpAddressPrefix) &&
        Objects.equals(this.destinationIpAddressPrefix, nfpRule.destinationIpAddressPrefix) &&
        Objects.equals(this.extendedCriteria, nfpRule.extendedCriteria);
  }

  @Override
  public int hashCode() {
    return Objects.hash(etherDestinationAddress, etherSourceAddress, etherType, vlanTag, protocol, dscp, sourcePortRange, destinationPortRange, sourceIpAddressPrefix, destinationIpAddressPrefix, extendedCriteria);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NfpRule {\n");
    
    sb.append("    etherDestinationAddress: ").append(toIndentedString(etherDestinationAddress)).append("\n");
    sb.append("    etherSourceAddress: ").append(toIndentedString(etherSourceAddress)).append("\n");
    sb.append("    etherType: ").append(toIndentedString(etherType)).append("\n");
    sb.append("    vlanTag: ").append(toIndentedString(vlanTag)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    dscp: ").append(toIndentedString(dscp)).append("\n");
    sb.append("    sourcePortRange: ").append(toIndentedString(sourcePortRange)).append("\n");
    sb.append("    destinationPortRange: ").append(toIndentedString(destinationPortRange)).append("\n");
    sb.append("    sourceIpAddressPrefix: ").append(toIndentedString(sourceIpAddressPrefix)).append("\n");
    sb.append("    destinationIpAddressPrefix: ").append(toIndentedString(destinationIpAddressPrefix)).append("\n");
    sb.append("    extendedCriteria: ").append(toIndentedString(extendedCriteria)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

